# [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/)

这道题相当于是[1004](https://leetcode.cn/problems/max-consecutive-ones-iii/description/)的`k = 1`的情况,用滑动窗口写的代码基本一模一样。

虽然这道题我写的时候知道可以用滑动窗口写，但是没有往这方面去想，而是投机取巧，以下是我写的代码，出现的问题基本都是边界处理,还用AI添加了注释和解释说明：

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        vector<int> res; // 用于存储数组中所有0的索引位置
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] == 0)
                res.push_back(i); // 将0的索引添加到res中
        }
        
        int m = res.size(); // 数组中0的总数量
        int n = nums.size(); // 数组的总长度
        int ans = 0; // 用于记录最长子数组的长度
        
        // 如果数组中没有0或者只有一个0
        if (m == 0 || m == 1)
            return n - 1; // 必须删除一个元素，结果为n-1
        
        // 如果数组中有两个0
        else if (m == 2)
            // 返回删除第一个0后的长度和删除第二个0后的长度中的较大值
            return max(res[1] - 1, n - res[0] - 2);
        
        // 初始化ans为删除第一个0后的最大长度和删除倒数第二个0后的最大长度中的较大值
        ans = max(res[1] - 1, n - res[m - 2] - 2);
        
        // 遍历中间的0，尝试删除每一个0，并计算删除后的最长连续1的长度
        for (int i = 1; i < m - 1; ++i) {
            // 计算删除第i个0后，左边一个0到右边一个0之间的1的数量
            ans = max(ans, res[i + 1] - res[i - 1] - 2);
        }
        
        return ans; // 返回计算得到的最长子数组长度
    }
};
```

### 详细说明

1. **收集所有0的索引：**
   ```cpp
   vector<int> res; // 用于存储数组中所有0的索引位置
   for (int i = 0; i < nums.size(); ++i) {
       if (nums[i] == 0)
           res.push_back(i); // 将0的索引添加到res中
   }
   ```
   - 遍历整个数组，记录所有0出现的位置索引，存储在`res`数组中。

2. **初始化变量：**
   ```cpp
   int m = res.size(); // 数组中0的总数量
   int n = nums.size(); // 数组的总长度
   int ans = 0; // 用于记录最长子数组的长度
   ```
   - `m`表示数组中0的数量，`n`是数组的长度，`ans`用于记录当前找到的最长连续1的长度。

3. **处理特殊情况：**
   ```cpp
   if (m == 0 || m == 1)
       return n - 1; // 必须删除一个元素，结果为n-1
   ```
   - 如果数组中没有0（即全是1），根据题意必须删除一个元素，最长连续1的长度为`n-1`。
   - 如果数组中只有一个0，删除这个0后，数组中最长的连续1的长度也是`n-1`。

4. **处理有两个0的情况：**
   ```cpp
   else if (m == 2)
       return max(res[1] - 1, n - res[0] - 2);
   ```
   - 当数组中有两个0时，可以选择删除第一个0或第二个0。
   - `res[1] - 1`表示删除第二个0后，前面的1的连续长度。
   - `n - res[0] - 2`表示删除第一个0后，末尾的1的连续长度。
   - 取两者中的较大值作为结果。

5. **处理多个0的情况：**
   ```cpp
   ans = max(res[1] - 1, n - res[m - 2] - 2);
   
   for (int i = 1; i < m - 1; ++i) {
       ans = max(ans, res[i + 1] - res[i - 1] - 2);
   }
   ```
   - 首先，初始化`ans`为删除第一个0或删除倒数第二个0后得到的最长连续1的长度中的较大值。
   - 然后，遍历所有中间的0（不包括第一个和最后一个），对每一个0，计算删除它后，前一个0和后一个0之间的1的数量，并更新`ans`为最大值。

6. **返回结果：**
   ```cpp
   return ans; // 返回计算得到的最长子数组长度
   ```
   - 最终返回计算得到的最长连续1的长度。

### 示例验证

让我们通过一些示例来验证代码的正确性：

- **示例 1：**
  ```cpp
  nums = [1,1,0,1]
  ```
  - 0的索引为`[2]`，`m = 1`。
  - 返回`4 - 1 = 3`，符合预期。

- **示例 2：**
  ```cpp
  nums = [0,1,1,1,0,1,1,0,1]
  ```
  - 0的索引为`[0, 4, 7]`，`m = 3`。
  - 初始化`ans = max(res[1] - 1, n - res[m - 2] - 2) = max(4 - 1, 9 - 4 - 2) = max(3, 3) = 3`。
  - 遍历中间的0（索引4）：
    - 计算`res[2] - res[0] - 2 = 7 - 0 - 2 = 5`，更新`ans = 5`。
  - 最终返回`5`，符合预期。

- **示例 3：**
  ```cpp
  nums = [1,1,1]
  ```
  - 没有0，`m = 0`。
  - 返回`3 - 1 = 2`，符合预期。

---

下面是滑动窗口的解法，也是用AI生成的，太爽了：

```cpp

class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int left = 0;           // 左指针
        int zeros = 0;          // 当前窗口中0的数量
        int maxOnes = 0;        // 记录最长的1子数组长度

        for (int right = 0; right < nums.size(); ++right) {
            if (nums[right] == 0)
                zeros++;

            // 如果窗口中0的数量超过1，移动左指针
            while (zeros > 1) {
                if (nums[left] == 0)
                    zeros--;
                left++;
            }

            // 更新最大值，窗口长度减去1（因为需要删除一个元素）
            maxOnes = max(maxOnes, right - left);
        }

        // 如果maxOnes等于数组长度，表示所有都是1，需删除一个元素
        return maxOnes;
    }
};

```

### 解释

1. **滑动窗口策略：**
   - 使用滑动窗口来维护当前窗口中0的数量不超过1。
   - 当0的数量超过1时，移动左指针，直到窗口中0的数量恢复到1或更少。

2. **计算最长子数组长度：**
   - 每次更新`maxOnes`时，用当前窗口的长度减去1，因为需要删除一个元素。
   - `right - left`实际上已经减去了要删除的那个元素的位置。

3. **处理全是1的情况：**
   - 如果整个数组都是1，`maxOnes`会等于`nums.size() - 1`，符合题意。

### 测试

让我们用你提供的测试用例来验证一下：

- **示例 1:**
  ```cpp
  nums = [1,1,0,1]
  输出: 3
  ```
  解释：删除第2个元素后的数组为 `[1,1,1]`，最长子数组长度为3。

- **示例 2:**
  ```cpp
  nums = [0,1,1,1,0,1,1,0,1]
  输出: 5
  ```
  解释：删除第4个元素后的数组为 `[0,1,1,1,1,1,0,1]`，最长子数组长度为5。

- **示例 3:**
  ```cpp
  nums = [1,1,1]
  输出: 2
  ```
  解释：删除任意一个1后的数组最长子数组长度为2。
