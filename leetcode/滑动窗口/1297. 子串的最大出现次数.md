# [1297. 子串的最大出现次数](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/)

又是一场酣畅淋漓的战斗啊，我又一次被打败了，兄弟们，这道题是我拼尽全力也无法战胜的敌人啊😂，虽然是有思路的，而且也算是正确的，但是就是不知道怎么去写，脑瓜子嗡嗡的，还是没实力啊，
下面是我把别人的Java题解用GPT转成的C++的代码，自己看去吧：

```cpp

class Solution {
public:
    int maxFreq(std::string s, int maxLetters, int minSize, int maxSize) {
        int n = s.length();
        // 用unordered_map记录子串出现的频率
        std::unordered_map<std::string, int> map;
        // 字符数组
        std::vector<int> count(128, 0);  // 用于记录字符的频次，128是因为ASCII码的范围
        int left = 0, right = 0, tmp = 0; // tmp记录当前窗口内不同字母的数量
        int ans = 0;  // 最终结果，最大出现次数
        
        while (right < n) {
            // 扩展窗口
            count[s[right]]++;
            // 如果当前字符出现次数为1，说明是一个新的不同字符
            if (count[s[right]] == 1) tmp++;
            right++;

            // 窗口的长度
            int len = right - left;

            // 如果窗口内的不同字母数大于maxLetters或者窗口长度大于minSize，左侧收缩窗口
            while (tmp > maxLetters || len > minSize) {
                count[s[left]]--;
                if (count[s[left]] == 0) tmp--;
                left++;
                len--;
            }

            // 如果满足条件（不同字母数小于等于maxLetters，且窗口长度等于minSize），就统计该子串
            if (tmp <= maxLetters && len == minSize) {
                std::string str = s.substr(left, minSize);
                map[str]++;
            }
        }

        // 找到出现次数最多的子串
        for (const auto& entry : map) {
            ans = std::max(ans, entry.second);
        }
        return ans;
    }
};
```

还是一句话，菜就多练。
