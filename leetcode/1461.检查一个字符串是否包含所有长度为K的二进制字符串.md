# [1461.检查一个字符串是否包含所有长度为K的二进制字符串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/)

这是一道典型的定长滑动窗口题，就是我写的时候很抽象，看代码就知道了：

```cpp
class Solution {
public:
    bool hasAllCodes(string s, int k) {
        unordered_set<string> hash;
    
        string c = "";
        int count = 1;

        for (int i = 0; i <= s.length() - k; ++i) {
            if (count <= k) {
                c += s[i];
                count++;
                continue;
            }
            hash.insert(c);
            c = "";
            count = 0;
        }

        if (hash.size() != 1 << k) 
            return false;
        return true;
    }
};

```
仔细看就会知道，虽然我一开始想的是从0开始遍历字符串到尾，然后每次取长度为 `k` 的字符串插入到 `set` 哈希表中，但是我忘了每次 `if`判断之后 `i` 的值都会改变,其实根本
遍历不了所有的字符串，所以我毁了。

下面看以下马斯克的 `grok-beta` 给我的代码做的修改

```cpp

class Solution {
public:
    bool hasAllCodes(string s, int k) {
        unordered_set<string> hash;
        
        // 如果s的长度小于k，则不可能包含所有长度为k的二进制子串
        if (s.length() < k) return false;

        // 初始化第一个k长度的子串
        string c = s.substr(0, k);
        hash.insert(c);

        // 从第二个字符开始构建子串
        for (int i = 1; i <= s.length() - k; ++i) {
            // 移除最左边的字符，添加最右边的字符
            c = c.substr(1) + s[i + k - 1];
            hash.insert(c);
        }

        // 检查是否包含了所有可能的二进制子串
        return hash.size() == (1 << k);
    }
};

```
本来我也想用 `substr` 的，但是感觉每次都会在系统中多创建一个字符串，感觉很浪费空间，就没用了。
