# [1461.检查一个字符串是否包含所有长度为K的二进制字符串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/)

## 这是一道典型的定长滑动窗口题，就是我写的时候很抽象，看代码就知道了：

```cpp
class Solution {
public:
    bool hasAllCodes(string s, int k) {
        unordered_set<string> hash;
    
        string c = "";
        int count = 1;

        for (int i = 0; i <= s.length() - k; ++i) {
            if (count <= k) {
                c += s[i];
                count++;
                continue;
            }
            hash.insert(c);
            c = "";
            count = 0;
        }

        if (hash.size() != 1 << k) 
            return false;
        return true;
    }
};

```
仔细看就会知道，虽然我一开始想的是从0开始遍历字符串到尾，然后每次取长度为 `k` 的字符串插入到 `set` 哈希表中，但是我忘了每次 `if`判断之后 `i` 的值都会改变,其实根本
遍历不了所有的字符串，所以我毁了。

## 下面看以下马斯克的 `grok-beta` 给我的代码做的修改

```cpp

class Solution {
public:
    bool hasAllCodes(string s, int k) {
        unordered_set<string> hash;
        
        // 如果s的长度小于k，则不可能包含所有长度为k的二进制子串
        if (s.length() < k) return false;

        // 初始化第一个k长度的子串
        string c = s.substr(0, k);
        hash.insert(c);

        // 从第二个字符开始构建子串
        for (int i = 1; i <= s.length() - k; ++i) {
            // 移除最左边的字符，添加最右边的字符
            c = c.substr(1) + s[i + k - 1];
            hash.insert(c);
        }

        // 检查是否包含了所有可能的二进制子串
        return hash.size() == (1 << k);
    }
};

```
本来我也想用 `substr` 的，但是感觉每次都会在系统中多创建一个字符串，感觉很浪费空间，就没用了。

## 然后下面是官方的题解之一，思路和我是一模一样的，都是存到 `set` 里面，然后遍历，判断是否有 `2<sup>k</sup>` 个元素即可。

```cpp

class Solution {
public:
    bool hasAllCodes(string s, int k) {
        if (s.size() < (1 << k) + k - 1) {
            return false;
        }

        unordered_set<string> exists;
        for (int i = 0; i + k <= s.size(); ++i) {
            exists.insert(move(s.substr(i, k)));
        }
        return exists.size() == (1 << k);
    }
};
```

下面是官方题解里面的 `move` 用法的解释：

在这个解决方案中，`move(s.substr(i, k))`的使用涉及到C++11引入的移动语义（Move Semantics）。下面是对`move`在这里起到的作用的分析：

1. **避免不必要的拷贝**：
   - `s.substr(i, k)`返回一个新的`std::string`对象，这个对象包含从`i`开始的`k`个字符。
   - 如果直接将这个子串插入到`unordered_set`中，通常会发生一次深拷贝，因为`unordered_set`需要存储一个独立的副本。
   - 通过`move`，我们可以将这个新创建的`std::string`对象的所有权直接转移给`unordered_set`，而不是创建一个新的拷贝。这意味着`unordered_set`会直接获取到这个临时字符串对象的所有权，而不需要额外分配内存或复制数据。

2. **性能优化**：
   - 减少了内存分配和数据复制的开销。移动操作通常比拷贝操作快得多，因为它只是将内部指针和状态信息从一个对象转移到另一个对象，而不需要实际复制字符串的内容。
   - 这对于处理大字符串或频繁的插入操作尤其重要，因为它可以显著减少内存分配和释放的次数，提高程序的运行效率。

3. **临时对象的生命周期**：
   - 使用`move`后，原来的`std::string`对象（即`substr`返回的临时对象）将被置于一个有效但未定义的状态（通常称为"moved-from"状态），意味着它不再拥有数据，但它仍然可以被安全地销毁。

4. **代码可读性和意图表达**：
   - 使用`move`明确地表达了我们希望避免拷贝的意图，使代码的意图更加清晰。

总的来说，`move`在这里的作用是为了提高性能，通过避免不必要的字符串拷贝来优化插入操作的效率。这个优化在处理大量字符串插入时尤其明显，因为它减少了内存操作和可能的内存碎片化问题。
