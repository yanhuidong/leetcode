# [2090. 半径为 k 的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/description/)

给你一个下标从 `0` 开始的数组 `nums`，数组中有 `n` 个整数，另给你一个整数 `k`。

**半径为 k 的子数组平均值** 是指：`nums` 中一个下标 `i` 为**中心**且**半径**为 `k` 的子数组中所有元素的平均值，即下标在 `i - k` 和 `i + k` 范围（含 `i - k` 和 `i + k`）内所有元素的平均值。如果在下标 `i` 前或后不足 `k` 个元素，那么**半径为 k 的子数组平均值**是 `-1`。

构建并返回一个长度为 `n` 的数组 `avgs`，其中 `avgs[i]` 是以下标 `i` 为中心的**半径为 k 的子数组的半径为 k 的子数组平均值**。

一个元素的**平均值**是**该元素相加之后除以 `x`**，此时使用截断式**整数除法**，即需要去掉结果的小数部分。

- 例如，四个元素 `2`、`3`、`1` 和 `5` 的平均值是 `(2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75`，截断后得到 `2`。

示例1：  

![](https://assets.leetcode.com/uploads/2021/11/07/eg1.png)  

> 输入：nums = [7,4,3,9,1,8,5,2,6], k = 3  
> 输出：[-1,-1,-1,5,4,4,-1,-1,-1]  
> 解释：  
> - avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。  
> - 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。  
>   使用截断式 整数除法，avg[3] = 37 / 7 = 5 。  
> - 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。  
> - 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。  
> - avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。

提示：
- `n == nums.length`
- `1 <= n <= 105`
- `0 <= nums[i], k <= 105`

在刷了多道滑动窗口的题目后，这种题我现在基本可以套模板写了，虽然偶尔还是会有一点小问题，但是基本可以通过。

下面是我写的代码，官方的代码比我的简洁，但是我的也不差，官方也就是用了[`accumulate`](../库函数 & 扩展知识/accumulate.md)库函数求和罢了，不过明明官方的题解也和我一样另外创建了一个新的数组来返回结果，但是硬要说空间复杂度是`O(1)`，也是没办法了。
```cpp

class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < 2 * k + 1)
            return vector<int>(n, -1);
        long long sum = 0.0;

        for (int i = 0; i < 2 * k + 1; ++i) {
            sum += nums[i];
        }

        result[k] = static_cast<int>(sum / (2 * k + 1));
        for (int i = 2 * k + 1; i < nums.size(); ++i) {
            sum = sum - nums[i - 2 * k - 1] + nums[i];
            result[i - k] = static_cast<int>(sum / (2 * k + 1));
        }

        return result;
    }
};
```
