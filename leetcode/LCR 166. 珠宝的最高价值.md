# [LCR 166. 珠宝的最高价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/)

现有一个记作二维矩阵 `frame` 的珠宝架，其中 `frame[i][j]` 为该位置珠宝的价值。拿取珠宝的规则为：

只能从架子的左上角开始拿珠宝
- 每次可以移动到右侧或下侧的相邻位置
- 到达珠宝架子的右下角时，停止拿取
- 注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 `frame = [[0]]`。

示例1：
> 输入: frame = [[1,3,1],[1,5,1],[4,2,1]]  
> 输出: 12  
> 解释: 路径 1→3→5→2→1 可以拿到最高价值的珠宝

## 下面是我自己写的，自己写出来还是很有成就感的，虽然空间复杂度有点大就是了

```cpp
class Solution {
public:
    int jewelleryValue(vector<vector<int>>& frame) {
        int length = frame.size();
        int width = frame[0].size();
        vector<vector<int>> dp(length, vector<int>(width, 0));
        dp[0][0] = frame[0][0];
        for (int i = 1; i < length; ++i) {
            dp[i][0] = frame[i][0] + dp[i - 1][0];
        }
        for (int j = 1; j < width; ++j) {
            dp[0][j] = frame[0][j] + dp[0][j - 1];
        }
        for (int i = 1; i < length; ++i) {
            for (int j = 1; j < width; ++j) {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + frame[i][j];
            }
        }
        return dp[length - 1][width - 1];
    }
};

```

### 代码解释

1. `dp[0][0] = frame[0][0];` ：初始化起点的珠宝价值。
2. 第一列的初始化循环：从上到下累加每一行。
3. 第一行的初始化循环：从左到右累加每一列。
4. 动态规划填充：对于每个 `dp[i][j]` ，从上方或左侧选择较大的值并加上当前 `frame[i][j]` 的值。
5. 最终返回 `dp[length － 1][width － 1]` ，即到达右下角时的最大珠宝价值。

### 时间和空间复杂度分析

**时间复杂度**

代码中主要的时间消耗在于两个嵌套的循环，用于填充`dp`数组的`dp[length][width]`，其中`length`是框架的长度和`width`是框架的宽度。

```cpp
for (int i = 1; i < length; ++i) {
    for (int j = 1; j < width; ++j) {
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + frame[i][j];
    }
}
```

这个循环会执行`length - 1`次和`width - 1`次，所以时间复杂度为：

```
时间复杂度 = O((length - 1) * (width - 1))
            = O(length * width)
```

**空间复杂度**

代码中创建了一个`dp`数组，其大小为`length * width`，用于存储中间结果。因此，空间复杂度为：

```
空间复杂度 = O(length * width)
```

**总结**

- 时间复杂度：O(length * width)
- 空间复杂度：O(length * width)

这里的`length`和`width`分别代表框架的长和宽，所以时间复杂度和空间复杂度都是线性的，与框架的大小成正比。

### Chatgpt 代码优化

```cpp

#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int jewelleryValue(vector<vector<int>>& frame) {
        int length = frame.size();
        int width = frame[0].size();
        
        // 使用两个一维数组来保存当前行和上一行的 DP 值
        vector<int> prev(width, 0), curr(width, 0);
        
        // 初始化第一个位置
        prev[0] = frame[0][0];
        
        // 初始化第一行的路径值
        for (int j = 1; j < width; ++j) {
            prev[j] = prev[j - 1] + frame[0][j];
        }
        
        // 填充 DP 数组的每一行
        for (int i = 1; i < length; ++i) {
            // 初始化当前行第一个位置
            curr[0] = prev[0] + frame[i][0];
            
            for (int j = 1; j < width; ++j) {
                curr[j] = max(prev[j], curr[j - 1]) + frame[i][j];
            }
            
            // 将当前行变为上一行，为下一行计算做准备
            prev = curr;
        }
        
        // 返回最终结果，即最后一行最后一个位置的值
        return prev[width - 1];
    }
};

```

### 优化后的复杂度分析

1. **时间复杂度**：时间复杂度仍然是`O(length× width)`，因为我们仍然需要遍历所有元素。
2. **空间复杂度**：使用了两个一维数组 `prev` 和`curr`，因此空间复杂度降低到 `O(width)`。

**总结**
通过这一优化，空间复杂度从 `O(length × width)`降低到 `O(width)`，从而节省了大量内存。
