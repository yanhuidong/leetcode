# [2748. 美丽下标对的数目](https://leetcode.cn/problems/number-of-beautiful-pairs/description/)

作为一道简单题，暴力破解什么的就不说了，但是如果这道题的数据量大一点的话，就会变成一道中等题了，而且也不是很简单的那种，所以就需要掌握非暴力方法，虽然我自己想破了头都没想出来，
但是我会看题解呀😂，然后看灵神的题解也就懂得差不多了，虽然代码有点难看懂，但是自己模拟一遍的话就会觉得写的实在太高明了，真的牛逼，非常简洁，我用AI都写不出这么简洁的代码，这也就是AI是不能完全
取代程序员的原因吧，所以我还要努力学习啊。

下面是灵神的代码，用AI生成了一点注释，最好自己模拟一遍，这样比较好懂

```cpp

class Solution {
public:
    int countBeautifulPairs(vector<int>& nums) {
        // 初始化美丽下标对的计数器
        int ans = 0;
        
        // 创建一个大小为10的计数数组，用于记录数字最高位的出现频率
        // 索引0-9对应数字0-9的出现次数
        int cnt[10]{};

        // 遍历输入数组中的每一个数字
        for (int x : nums) {
            // 内层循环：检查当前数字与之前出现过的数字的最高位是否构成美丽下标对
            for (int y = 1; y < 10; y++) {
                // 条件1：y的频率大于0（即之前已经出现过以y为最高位的数字）
                // 条件2：当前数字的末位数字和y互质
                if (cnt[y] && gcd(y, x % 10) == 1) {
                    // 如果满足上述两个条件，累加美丽下标对的数量
                    // cnt[y]表示之前出现过的以y为最高位的数字的数量
                    ans += cnt[y];
                }
            }

            // 提取当前数字的最高位（首位）
            // 通过不断除以10，直到数字小于10
            while (x >= 10) { 
                x /= 10;
            }

            // 更新最高位的出现频率
            // x现在是原始数字的最高位
            cnt[x]++;
        }

        // 返回美丽下标对的总数
        return ans;
    }
};

```
